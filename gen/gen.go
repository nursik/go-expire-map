package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"strings"
	"text/template"
)

var key = flag.String("k", "interface{}", "name of key struct")
var value = flag.String("v", "interface{}", "name of value struct")
var mapname = flag.String("mp", "ExpireMap", "name of map")
var zerovalue = flag.String("zv", "", "zero value for value (for pointers - type nil, struct T - type &T{})")

var outTemplate = `
// Auto-generated by github.com/nursik/go-expire-map/gen/gen.go
import (
	"github.com/nursik/go-ordered-set"
	"math/rand"
	"sync"
	"sync/atomic"
	"time"
)

const timeResolution = time.Millisecond

const expireInterval = 100 * time.Millisecond

type KeyValue struct {
	Key   {{ .Key}}
	Value {{ .Value}}
}

type item struct {
	ttl   int64
	key   {{ .Key}}
	value {{ .Value}}
}

const pageBitSize = 10
const pageSize = 1 << pageBitSize
const pagesPerMap = 1000000

type page struct {
	size   int
	values [pageSize]item
}

type pages struct {
	pages [pagesPerMap]*page
}

func (ps *pages) put(index uint64, v item) {
	bucket := index >> pageBitSize
	if ps.pages[bucket] == nil {
		ps.pages[bucket] = &page{}
	}
	page := ps.pages[bucket]
	page.values[index&(1<<pageBitSize-1)] = v
	page.size++
}

func (ps *pages) remove(index uint64) {
	bucket := index >> pageBitSize
	page := ps.pages[bucket]
	page.size--
	if page.size == 0 {
		ps.pages[bucket] = nil
	} else {
		page.values[index&(1<<pageBitSize-1)].value = {{ .ValueZero}}
	}
}

func (ps *pages) get(index uint64) item {
	bucket := index >> pageBitSize
	return ps.pages[bucket].values[index&(1<<pageBitSize-1)]
}

type {{ .MapName}} struct {
	keys    map[{{ .Key}}]uint64
	values  *pages
	indices orderedset.OrderedSet
	mutex   sync.RWMutex
	stopped int64
	curtime int64
}

func (m *{{ .MapName}}) SetTTL(key {{ .Key}}, due time.Duration) ({{ .Value}}, bool) {
	if due <= timeResolution {
		m.Delete(key)
		return nil, false
	}
	ttl := int64(due/time.Nanosecond) + m.Curtime()

	m.mutex.Lock()
	if m.Stopped() {
		m.mutex.Unlock()
		return {{ .ValueZero}}, false
	}
	id, ok := m.keys[key]
	if ok == false {
		m.mutex.Unlock()
		return {{ .ValueZero}}, false
	}
	v := m.values.get(id)
	if v.ttl <= m.Curtime() {
		m.del(key, id)
		m.mutex.Unlock()
		return {{ .ValueZero}}, false
	}
	v.ttl = ttl
	m.values.put(id, v)
	m.mutex.Unlock()
	return v.value, true
}

func (m *{{ .MapName}}) Get(key {{ .Key}}) ({{ .Value}}, bool) {
	m.mutex.RLock()
	if m.Stopped() {
		m.mutex.RUnlock()
		return {{ .ValueZero}}, false
	}
	id, ok := m.keys[key]
	if ok == false {
		m.mutex.RUnlock()
		return {{ .ValueZero}}, false
	}
	v := m.values.get(id)
	if v.ttl > m.Curtime() {
		m.mutex.RUnlock()
		return v.value, true
	}
	m.mutex.RUnlock()
	m.mutex.Lock()
	if m.Stopped() {
		m.mutex.Unlock()
		return {{ .ValueZero}}, false
	}

	id, ok = m.keys[key]
	if ok == false {
		m.mutex.Unlock()
		return {{ .ValueZero}}, false
	}

	v = m.values.get(id)
	if v.ttl > m.Curtime() {
		m.mutex.Unlock()
		return v.value, true
	}

	m.del(key, id)
	m.mutex.Unlock()
	return {{ .ValueZero}}, false
}

func (m *{{ .MapName}}) GetTTL(key {{ .Key}}) int64 {
	m.mutex.RLock()
	if m.Stopped() {
		m.mutex.RUnlock()
		return 0
	}
	id, ok := m.keys[key]
	if ok == false {
		m.mutex.RUnlock()
		return 0
	}
	v := m.values.get(id)
	if cur := m.Curtime(); v.ttl > cur {
		ttl := v.ttl - cur
		m.mutex.RUnlock()
		return ttl
	}
	m.mutex.RUnlock()
	return 0
}

func (m *{{ .MapName}}) Delete(key {{ .Key}}) {
	m.mutex.Lock()
	if m.Stopped() {
		m.mutex.Unlock()
		return
	}
	if id, ok := m.keys[key]; ok {
		m.del(key, id)
	}
	m.mutex.Unlock()
}

func (m *{{ .MapName}}) Close() {
	m.mutex.Lock()
	if m.Stopped() == false {
		atomic.StoreInt64(&m.stopped, 1)
		m.keys = nil
		m.values = nil
		m.indices = nil
	}
	m.mutex.Unlock()
}

func (m *{{ .MapName}}) Set(key {{ .Key}}, value {{ .Value}}, due time.Duration) {
	if due < timeResolution {
		return
	}
	ttl := int64(due/time.Nanosecond) + m.Curtime()
	m.mutex.Lock()
	if m.Stopped() {
		m.mutex.Unlock()
		return
	}

	id, ok := m.keys[key]
	if !ok {
		id = m.indices.LowestUnused()
		m.indices.Insert(id)
		m.keys[key] = id
	}
	m.values.put(id, item{
		key:   key,
		value: value,
		ttl:   ttl,
	})
	m.mutex.Unlock()
}

func (m *{{ .MapName}}) GetAll() []KeyValue {
	m.mutex.RLock()
	if m.Stopped() {
		m.mutex.RUnlock()
		return nil
	}
	sz := m.indices.Size()
	ans := make([]KeyValue, 0, sz)
	curtime := m.Curtime()
	for i := 0; i < sz; i++ {
		id := m.indices.Kth(i)
		v := m.values.get(id)
		if v.ttl > curtime {
			ans = append(ans, KeyValue{Key: v.key, Value: v.value})
		}
	}
	m.mutex.RUnlock()
	return ans
}

func (m *{{ .MapName}}) Size() int {
	m.mutex.RLock()
	sz := len(m.keys)
	m.mutex.RUnlock()
	return sz
}

func (m *{{ .MapName}}) Stopped() bool {
	return atomic.LoadInt64(&m.stopped) == 1
}

func (m *{{ .MapName}}) Curtime() int64 {
	return atomic.LoadInt64(&m.curtime)
}

func (m *{{ .MapName}}) del(key {{ .Key}}, id uint64) {
	delete(m.keys, key)
	m.values.remove(id)
	m.indices.Remove(id)
}

func (m *{{ .MapName}}) randomExpire() bool {
	const totalChecks = 20
	const bruteForceThreshold = 100
	if m.Stopped() {
		return false
	}
	// Because the number of keys is small, just iterate over all keys
	if sz := m.indices.Size(); sz <= bruteForceThreshold {
		for i := sz - 1; i >= 0; i-- {
			id := m.indices.Kth(i)
			v := m.values.get(id)
			if v.ttl <= m.Curtime() {
				m.del(v.key, id)
			}
		}
		return false
	}

	expiredFound := 0

	for i := 0; i < totalChecks; i++ {
		sz := m.indices.Size()
		id := m.indices.Kth(rand.Intn(sz))
		v := m.values.get(id)
		if v.ttl <= m.Curtime() {
			m.del(v.key, id)
			expiredFound++
		}
	}

	if expiredFound*4 >= totalChecks {
		return true
	}
	return false
}

func (m *{{ .MapName}}) rotateExpire(kth int) int {
	const totalChecks = 20
	if m.Stopped() {
		return 0
	}
	sz := m.indices.Size()
	if sz == 0 {
		return 0
	}
	if kth >= sz || kth <= 0 {
		kth = sz - 1
	}
	for i := 0; i < totalChecks; i++ {
		id := m.indices.Kth(kth)
		v := m.values.get(id)
		if v.ttl <= m.Curtime() {
			m.del(v.key, id)
		}
		kth--
		if kth < 0 {
			break
		}
	}
	return kth
}

func (m *{{ .MapName}}) start() {
	go func() {
		for {
			if m.Stopped() {
				break
			}
			atomic.StoreInt64(&m.curtime, time.Now().UnixNano())
			time.Sleep(timeResolution)
		}
	}()

	go func() {
		kth := 0
		for {
			if m.Stopped() {
				break
			}
			start := time.Now()
			for i := 0; i < 10; i++ {
				m.mutex.Lock()
				if !m.randomExpire() {
					m.mutex.Unlock()
					break
				}
				m.mutex.Unlock()
			}
			m.mutex.Lock()
			kth = m.rotateExpire(kth)
			m.mutex.Unlock()
			diff := time.Since(start)
			time.Sleep(expireInterval - diff)
		}
	}()
}

func New() *{{ .MapName}} {
	rl := &{{ .MapName}}{
		keys:    make(map[{{ .Key}}]uint64),
		indices: orderedset.NewTreeSet(),
		values:  &pages{},
		curtime: time.Now().UnixNano(),
	}
	rl.start()
	return rl
}

`

type R struct {
	Key       string
	Value     string
	ValueZero string
	MapName   string
}

func main() {
	flag.Parse()

	r := R{
		Key:       *key,
		Value:     *value,
		ValueZero: "&" + *value + "{}",
		MapName:   *mapname,
	}
	if v := *value; v == "interface{}" || strings.HasPrefix(v, "*") {
		r.ValueZero = "nil"
	}
	if *zerovalue != "" {
		r.ValueZero = *zerovalue
	}
	fmt.Fprintf(os.Stderr, "Key - %s, Value - %s, Zero Value - %s, Map name - %s\nWriting results to stdout\n", r.Key, r.Value, r.ValueZero, r.MapName)

	t, err := template.New("output").Parse(outTemplate)

	if err != nil {
		log.Fatal(err)
	}

	err = t.Execute(os.Stdout, r)

	if err != nil {
		log.Fatal(err)
	}
}
