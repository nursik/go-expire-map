package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"strings"
	"text/template"
)

var mapOutput = `
// Auto-generated by github.com/nursik/go-expire-map/gen/gen.go
import (
	"github.com/nursik/go-ordered-set"
	"math/rand"
	"sync"
	"sync/atomic"
	"time"
)

const timeResolution = time.Millisecond
const expireInterval = 100 * time.Millisecond

{{if .Notify}} 
type EventType uint8
const (
	Expire EventType = 1 << iota
	Delete
	Update
	Set
	AllEvents = Expire | Delete | Update | Set
	NoEvents = 0
)

type Event struct {
	Key   {{ .Key}}
	Value {{ .Value}}
	Time int64
	Due int64
	Type EventType
}
{{- end}}
type KeyValue struct {
	Key   {{ .Key}}
	Value {{ .Value}}
}

type item struct {
	due   int64
	key   {{ .Key}}
	value {{ .Value}}
}

const pageBitSize = 10
const pageSize = 1 << pageBitSize
const pagesPerMap = 1000000

type page struct {
	size   int
	values [pageSize]item
}

type pages struct {
	pages [pagesPerMap]*page
}

func (ps *pages) put(index uint64, v item) {
	bucket := index >> pageBitSize
	if ps.pages[bucket] == nil {
		ps.pages[bucket] = &page{}
	}
	page := ps.pages[bucket]
	page.values[index&(1<<pageBitSize-1)] = v
	page.size++
}

func (ps *pages) remove(index uint64) {
	bucket := index >> pageBitSize
	page := ps.pages[bucket]
	page.size--
	if page.size == 0 {
		ps.pages[bucket] = nil
	} else {
		page.values[index&(1<<pageBitSize-1)].value = {{ .ValueZero}}
	}
}

func (ps *pages) get(index uint64) item {
	bucket := index >> pageBitSize
	return ps.pages[bucket].values[index&(1<<pageBitSize-1)]
}

type ExpireMap struct {
	keys    map[{{ .Key}}]uint64
	values  *pages
	indices orderedset.OrderedSet
	mutex   sync.RWMutex
	stopped int64
	curtime int64
{{if .Notify}}
	c       chan<- Event
	events  EventType
{{- end}}
}

func (m *{{ .MapName}}) SetTTL(key {{ .Key}}, ttl time.Duration) ({{ .Value}}, bool) {
	if ttl <= timeResolution {
		m.Delete(key)
		return {{ .ValueZero}}, false
	}
	due := int64(ttl/time.Nanosecond) + m.Curtime()

	m.mutex.Lock()
	if m.Stopped() {
		m.mutex.Unlock()
		return {{ .ValueZero}}, false
	}
	id, ok := m.keys[key]
	if ok == false {
		m.mutex.Unlock()
		return {{ .ValueZero}}, false
	}
	v := m.values.get(id)
	if v.due <= m.Curtime() {
		m.del(key, id, Expire)
		m.mutex.Unlock()
		return {{ .ValueZero}}, false
	}
	{{if .Notify}}
	if (m.events&Update) > 0 && m.c != nil {
		m.c <- Event{
			Key:   key,
			Value: v.value,
			Type:  Update,
			Time:  m.Curtime(),
			Due:   due,
		}
	}
	{{- end}}
	v.due = due
	m.values.put(id, v)
	m.mutex.Unlock()
	return v.value, true
}

func (m *{{ .MapName}}) Get(key {{ .Key}}) ({{ .Value}}, bool) {
	m.mutex.RLock()
	if m.Stopped() {
		m.mutex.RUnlock()
		return {{ .ValueZero}}, false
	}
	id, ok := m.keys[key]
	if ok == false {
		m.mutex.RUnlock()
		return {{ .ValueZero}}, false
	}
	v := m.values.get(id)
	if v.due > m.Curtime() {
		m.mutex.RUnlock()
		return v.value, true
	}
	m.mutex.RUnlock()
	m.mutex.Lock()
	if m.Stopped() {
		m.mutex.Unlock()
		return {{ .ValueZero}}, false
	}

	id, ok = m.keys[key]
	if ok == false {
		m.mutex.Unlock()
		return {{ .ValueZero}}, false
	}

	v = m.values.get(id)
	if v.due > m.Curtime() {
		m.mutex.Unlock()
		return v.value, true
	}

	m.del(key, id, Expire)
	m.mutex.Unlock()
	return {{ .ValueZero}}, false
}

func (m *{{ .MapName}}) GetTTL(key {{ .Key}}) int64 {
	m.mutex.RLock()
	if m.Stopped() {
		m.mutex.RUnlock()
		return 0
	}
	id, ok := m.keys[key]
	if ok == false {
		m.mutex.RUnlock()
		return 0
	}
	v := m.values.get(id)
	if cur := m.Curtime(); v.due > cur {
		ttl := v.due - cur
		m.mutex.RUnlock()
		return ttl
	}
	m.mutex.RUnlock()
	return 0
}

func (m *{{ .MapName}}) Delete(key {{ .Key}}) {
	m.mutex.Lock()
	if m.Stopped() {
		m.mutex.Unlock()
		return
	}
	if id, ok := m.keys[key]; ok {
		m.del(key, id, Delete)
	}
	m.mutex.Unlock()
}

func (m *{{ .MapName}}) Close() {
	m.mutex.Lock()
	if m.Stopped() == false {
		atomic.StoreInt64(&m.stopped, 1)
		m.keys = nil
		m.values = nil
		m.indices = nil
		m.c = nil
	}
	m.mutex.Unlock()
}

func (m *{{ .MapName}}) Set(key {{ .Key}}, value {{ .Value}}, ttl time.Duration) {
	if ttl < timeResolution {
		return
	}
	due := int64(ttl/time.Nanosecond) + m.Curtime()
	m.mutex.Lock()
	if m.Stopped() {
		m.mutex.Unlock()
		return
	}

	{{if .Notify}}
	t := Update
	{{- end}}
	id, ok := m.keys[key]
	if !ok {
		id = m.indices.LowestUnused()
		m.indices.Insert(id)
		m.keys[key] = id
		{{if .Notify}}
		t = Set
		{{- end}}
	}
	m.values.put(id, item{
		key:   key,
		value: value,
		due:   due,
	})
	{{if .Notify}}
	if (m.events&t) > 0 && m.c != nil {
		m.c <- Event{
			Key:   key,
			Value: value,
			Due:   due,
			Time:  m.Curtime(),
			Type:  t,
		}
	}
	{{- end}}
	m.mutex.Unlock()
}

func (m *{{ .MapName}}) GetAll() []KeyValue {
	m.mutex.RLock()
	if m.Stopped() {
		m.mutex.RUnlock()
		return nil
	}
	sz := m.indices.Size()
	ans := make([]KeyValue, 0, sz)
	curtime := m.Curtime()
	for i := 0; i < sz; i++ {
		id := m.indices.Kth(i)
		v := m.values.get(id)
		if v.due > curtime {
			ans = append(ans, KeyValue{Key: v.key, Value: v.value})
		}
	}
	m.mutex.RUnlock()
	return ans
}

func (m *{{ .MapName}}) Size() int {
	m.mutex.RLock()
	sz := len(m.keys)
	m.mutex.RUnlock()
	return sz
}

func (m *{{ .MapName}}) Stopped() bool {
	return atomic.LoadInt64(&m.stopped) == 1
}

func (m *{{ .MapName}}) Curtime() int64 {
	return atomic.LoadInt64(&m.curtime)
}
{{if .Notify}}
func (m *{{ .MapName}}) Notify(c chan<- Event, events EventType) {
	m.mutex.Lock()
	if m.Stopped() {
		m.mutex.Unlock()
		return
	}
	m.c = c
	m.events = events
	m.mutex.Unlock()
}
{{- end}}
func (m *{{ .MapName}}) del(key {{ .Key}}, id uint64, t EventType) {
	delete(m.keys, key)
	{{if .Notify}}
	if (m.events&t) > 0 && m.c != nil {
		i := m.values.get(id)
		m.c <- Event{
			Key:   key,
			Value: i.value,
			Time:  m.Curtime(),
			Type:  t,
		}
	}
	{{- end}}
	m.values.remove(id)
	m.indices.Remove(id)
}

func (m *{{ .MapName}}) randomExpire() bool {
	const totalChecks = 20
	const bruteForceThreshold = 100
	if m.Stopped() {
		return false
	}
	if sz := m.indices.Size(); sz <= bruteForceThreshold {
		for i := sz - 1; i >= 0; i-- {
			id := m.indices.Kth(i)
			v := m.values.get(id)
			if v.due <= m.Curtime() {
				m.del(v.key, id, Expire)
			}
		}
		return false
	}

	expiredFound := 0

	for i := 0; i < totalChecks; i++ {
		sz := m.indices.Size()
		id := m.indices.Kth(rand.Intn(sz))
		v := m.values.get(id)
		if v.due <= m.Curtime() {
			m.del(v.key, id, Expire)
			expiredFound++
		}
	}

	if expiredFound*4 >= totalChecks {
		return true
	}
	return false
}

func (m *{{ .MapName}}) rotateExpire(kth int) int {
	const totalChecks = 20
	if m.Stopped() {
		return 0
	}
	sz := m.indices.Size()
	if sz == 0 {
		return 0
	}
	if kth >= sz || kth <= 0 {
		kth = sz - 1
	}
	for i := 0; i < totalChecks; i++ {
		id := m.indices.Kth(kth)
		v := m.values.get(id)
		if v.due <= m.Curtime() {
			m.del(v.key, id, Expire)
		}
		kth--
		if kth < 0 {
			break
		}
	}
	return kth
}

func (m *{{ .MapName}}) start() {
	go func() {
		for {
			if m.Stopped() {
				break
			}
			atomic.StoreInt64(&m.curtime, time.Now().UnixNano())
			time.Sleep(timeResolution)
		}
	}()

	go func() {
		kth := 0
		for {
			if m.Stopped() {
				break
			}
			start := time.Now()
			for i := 0; i < 10; i++ {
				m.mutex.Lock()
				if !m.randomExpire() {
					m.mutex.Unlock()
					break
				}
				m.mutex.Unlock()
			}
			m.mutex.Lock()
			kth = m.rotateExpire(kth)
			m.mutex.Unlock()
			diff := time.Since(start)
			time.Sleep(expireInterval - diff)
		}
	}()
}

func New() *{{ .MapName}} {
	rl := &{{ .MapName}}{
		keys:    make(map[{{ .Key}}]uint64),
		indices: orderedset.NewTreeSet(),
		values:  &pages{},
		curtime: time.Now().UnixNano(),
	}
	rl.start()
	return rl
}

`

func main() {

	r := struct {
		Key       string
		Value     string
		ValueZero string
		MapName   string
		Notify    bool
	}{}

	flag.StringVar(&r.Key, "k", "interface{}", "name of key struct")
	flag.StringVar(&r.Value, "v", "interface{}", "name of value struct")
	flag.StringVar(&r.ValueZero, "zv", "", "zero value for values (for pointers - type nil, struct T - type &T{})")
	flag.StringVar(&r.MapName, "mp", "ExpireMap", "name of map")
	flag.BoolVar(&r.Notify, "n", true, "presence of Notify method")
	flag.Parse()

	if r.ValueZero == "" {
		if v := r.Value; v == "interface{}" || strings.HasPrefix(v, "*") {
			r.ValueZero = "nil"
		} else {
			r.ValueZero = r.Value + "{}"
		}
	}
	fmt.Fprintf(os.Stderr, "Key - %s, Value - %s, Zero Value - %s, Map name - %s, Use notify - %t\nWriting results to stdout\n", r.Key, r.Value, r.ValueZero, r.MapName, r.Notify)

	t, err := template.New("output").Parse(mapOutput)

	if err != nil {
		log.Fatal(err)
	}

	err = t.Execute(os.Stdout, r)

	if err != nil {
		log.Fatal(err)
	}
}
